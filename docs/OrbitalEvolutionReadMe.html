<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>poet: The Python Orbital Evolution Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">poet
   &#160;<span id="projectnumber">unspecified</span>
   </div>
   <div id="projectbrief">Evolve orbits under tides</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('OrbitalEvolutionReadMe.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Python Orbital Evolution Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A module for calculating orbital evolutions of two body systems in cilcular orbits. Both bodies consist of possibly dissipative zones each with its own angular momentum vector allowed to point in an arbitrary direction. All neighboring zones exchange angular momentum and the outermost zone possibly loses angular momentum due to magnetically launched wind. All frequency components of the dissipation are treated separately with their own tidal frequency. The dissipation efficiency is a broken powerlaw of tidal and stellar spin frequency.</p>
<p>One of the bodies is always a star (otherwise no evolution can happen) and the other could be another star or a planet. A planet in POET is an extremely simple objects which just has a constant mass and radius, consisting of a single, non-dissipative zone, which does not lose angular momentum to wind.</p>
<p>In order to calculate the evolution of a planet-star system the basic steps are:</p><ul>
<li>Create a stellar evolution interpolator</li>
<li>Create, configure and initialize a star</li>
<li>Create a planet</li>
<li>Combine the two objects in a binary</li>
<li>Calculate the evolution and query the results</li>
</ul>
<p>Details on how to accomplish each step follow:</p>
<h2>Create a Stellar Evolution Interpolator </h2>
<p>More details about stellar evolution interpolators are given <a class="el" href="StellarEvolutionReadMe.html">here</a>, but the basic steps are: </p><pre class="fragment">from poet.stellar_evolution.manager import StellarEvolutionManager
import numpy

%Create a manager
manager = StellarEvolutionManager(&lt;path to serialized interpolators&gt;)

%Find and use the default interpolator
interpolator = manager.get_interpolator_by_name('default')
</pre><h2>Create, Configure and Initialize a <a class="el" href="namespaceStar.html">Star</a> </h2>
<p>Given an interpolator a star with a given mass, [Fe/H], spin-down model parameters and dissipation parameters is created and prepared for evolution as follows: </p><pre class="fragment">from orbital_evolution.transformations import phase_lag
from orbital_evolution.star_interface import EvolvingStar

%Create the star with
%   mass of 1 solar mass
%   [Fe/H] = 0
%   Spin-down parameters: K_w = 0.17 in solar units times rad/day per Gyr
%                         \omega_{sat} = 2.45 rad/day
%   core-envelope coupling timescale of 5Myrs
star = EvolvingStar(mass = 1.0,
                    metallicity = 0.0,
                    wind_strength = 0.17,
                    wind_saturation_frequency = 2.45,
                    diff_rot_coupling_timescale = 5.0e-3,
                    interpolator = interpolator)

%Prepare the stellar evolution interpolation to start following the
%evolution of the star as soon as the core stars to form.
star.select_interpolation_region(star.core_formation_age())

%Define the dissipation of the stellar envelope. In this case, a constant
%phase lag corresponding to \form#328
star.set_dissipation(zone_index = 0,
                     tidal_frequency_breaks = None,
                     spin_frequency_breaks = None,
                     tidal_frequency_powers = numpy.array([0.0]),
                     spin_frequency_powers = numpy.array([0.0]),
                     reference_phase_lag = phase_lag(6.0))

%Make the stellar core non-dissipative.
star.set_dissipation(zone_index = 1,
                     tidal_frequency_breaks = None,
                     spin_frequency_breaks = None,
                     tidal_frequency_powers = numpy.array([0.0]),
                     spin_frequency_powers = numpy.array([0.0]),
                     reference_phase_lag = 0.0)
</pre><h2>Create a <a class="el" href="namespacePlanet.html">Planet</a> </h2>
<p>Creating planets is very simple. One only needs to specify the mass and radius <b>in soler units</b>. </p><pre class="fragment">from orbital_evolution.planet_interface import LockedPlanet
from astropy import units, constants

%Create a planet with a Jovian mass and radius
planet = LockedPlanet(
    mass = (constants.M_jup / constants.M_sun).to(''),
    radius = (constants.R_jup / constants.R_sun).to('')
)
</pre><h2>Combine the Two Objects in a Binary </h2>
<p>A star and a planet can be combined in a binary which is then prepared for evolution calculations as follows: </p><pre class="fragment">from orbital_evolution.binary import Binary
from math import pi
import numpy

%Create a binary with the primary object being the star and the seconday
%being an initially non-existent the planet, which forms when the
%protoplanetary disk dissipates (in this case 4Myrs) with an initial orbital
%period of 3 days in a circular and aligned orbit.
%Prior to the planet formith the stellar envelope spin frequency is held
%fixed (presumably locked to the inner edge of the disk) at a period of 7
%days.
binary = Binary(primary = star,
                secondary = planet,
                initial_orbital_period = 3.0,
                initial_eccentricity = 0.0,
                initial_inclination = 0.0,
                disk_lock_frequency = 2.0 * pi / 7.0,
                disk_dissipation_age = 4e-3,
                secondary_formation_age = 4e-3)

%Specify the initial conditions at which the binary starts. In thisa cese
%trivial since the planet does not exist at the start of the evolution
%calculations.
binary.configure(age = star.core_formation_age(),
                 semimajor = float('nan'),
                 eccentricity = float('nan'),
                 spin_angmom = numpy.array([0.0]),
                 inclination = None,
                 periapsis = None,
                 evolution_mode = 'LOCKED_SURFACE_SPIN')

%Configure the planet in the state in which it will form.
planet.configure(age = disk_dissipation_age,
                 companion_mass = star.mass,
                 semimajor = binary.semimajor(porb_initial),
                 eccentricity = 0.0,
                 spin_angmom = numpy.array([0.0]),
                 inclination = None,
                 periapsis = None,
                 locked_surface = False,
                 zero_outer_inclination = True,
                 zero_outer_periapsis = True)

%Configuring the binary (the first command above) will trigger configuring
%the star, and before evolution starts the star needs to set its wind
%saturation flag per its current state.
star.detect_stellar_wind_saturation()
</pre><h2>Calculate the evolution and query the results </h2>
<p>Once we have a binary system, the following calculates the evolution and obtains the specified quantities at each timestep: </p><pre class="fragment">%Calculate the evolution to a final age of 10Gyrs
%With a maximum step size of 1Myr
%With the ODE solver precision set ot 10^-6
%An empty list of ages which the evolution must precisely visit
binary.evolve(10.0, 0.001, 1e-6, None)

%Select the quantities to get at each evolution timestep.
%Further requests for quantities can be made later without re-calculating
%the evolution.
evolution_quantities = ['age',
                        'semimajor',
                        'envelope_angmom',
                        'core_angmom',
                        'wind_saturation']

%Get the specified quantities as a numpy record array with record names
%given by the quantity names above.
evolution = binary.get_evolution(evolution_quantities)</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Aug 2 2018 22:06:52 for poet by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
