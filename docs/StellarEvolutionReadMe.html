<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>poet: The Python Stellar Evolution Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">poet
   &#160;<span id="projectnumber">unspecified</span>
   </div>
   <div id="projectbrief">Evolve orbits under tides</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('StellarEvolutionReadMe.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Python Stellar Evolution Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A module for interpolating among existing stellar evolution tracks. Since generating the interpolation is quite slow, POET supports "serializing" (storing as a file on disk) a computed interpolation. The <code><a class="el" href="namespacestellar__evolution_1_1manager.html">stellar_evolution.manager</a></code> sub-module keeps track of exsiting interpolations, reusing them whenever appropriate, so this is the suggested interface.</p>
<h3>Basic usage :</h3>
<p>The user requests an interpolator from the manager by specifying either the interpolator name (using the <code>StellarEvolutionManager.get_interpolator_by_name</code> method) or by specifying a configuration for the interpolator. In the former case, it is an error to request an intorpolator with a name not previously defined (POET comes with a pre-defined interpolator named <code>default</code>). In the latter case, if the user specifies a name to assign to the new interpolator, the manager will automatically generate an interpolator if one does not exist. </p><pre class="fragment">from poet.stellar_evolution.manager import StellarEvolutionManager
import numpy

%Create a manager
manager = StellarEvolutionManager(&lt;path to serialized interpolators&gt;)

%Find and use the default interpolator
interpolator = manager.get_interpolator_by_name('default')

% The convective zone moment of inertia for a 0.73 solar mass star with
% [Fe/H] = -0.13
iconv = interpolator('ICONV', 0.73, -0.13)

% Evaluate the moment of inertia at a list of ages.
iconv_values = iconv(numpy.linspace(0.05, 10.0, 100))
</pre><h3>Custom interpolation using the package tracks:</h3>
<p>If for some reason the standard interpolation is not optimal for your purposes, it is possible to modify the parameters for how each quantity's age interpolation is performed (the subsequent interpolation in mass and metallicity is always done using a bi-cubic spline): </p><pre class="fragment">% construct an interpolator using only a subset of the tracks, as well
% as custom smoothing and number of nodes.
interpolator = manager.get_interpolator(
    nodes = dict(RADIUS = &lt;int&gt;,    %number of nodes for the radius age
                                    %interpolation
                 ICONV  = &lt;int&gt;,    %convective moment of inertia nodes
                 LUM    = &lt;int&gt;,    %luminosity nodes
                 IRAD   = &lt;int&gt;,    %radiative moment of inertia nodes
                 MRAD   = &lt;int&gt;,    %radiative mass nodes
                 RRAD   = &lt;int&gt;),   %tachocline radius nodes
    smoothing = dict(RADIUS = &lt;float&gt;,  %smoothing parameter for the
                                        %radius age interpolation
                     ICONV  = &lt;float&gt;,  %convective moment of inertia
                                        %smoothig
                     LUM    = &lt;float&gt;,  %luminosity smoothing
                     IRAD   = &lt;float&gt;,  %radiative moment of inertia
                                        %smoothing
                     MRAD   = &lt;float&gt;,  %radiative mass smoothing
                     RRAD   = &lt;float&gt;), %tachocline radius smoothing
    vs_log_age = dict(RADIUS = &lt;bool&gt;,  %should the independent argument
                                        %for radius interpolation be
                                        %log(age) instead of age?
                     ICONV  = &lt;bool&gt;,   %Same as RADIUS but for the
                                        %convective moment of inertia.
                     LUM    = &lt;bool&gt;,   %same as RADIUS but for luminosity.
                     IRAD   = &lt;float&gt;,  %same as RADIUS but for radiative
                                        %moment of inertia.
                     MRAD   = &lt;float&gt;,  %same as RADIUS but for mass in the
                                        %radiative core.
                     RRAD   = &lt;float&gt;), %same as RADIUS but for radius in
    log_quantity = dict(RADIUS = &lt;bool&gt;,  %should the log(radius) be used
                                          %in the interpolation instead of
                                          %radius?
                        ICONV  = &lt;bool&gt;,  %Same as RADIUS but for the
                                          %convective moment of inertia.
                        LUM    = &lt;bool&gt;,  %same as RADIUS but for
                                          %luminosity.
                        IRAD   = &lt;float&gt;, %same as RADIUS but for radiative
                                          %moment of inertia.
                        MRAD   = &lt;float&gt;, %same as RADIUS but for mass in
                                          %the radiative core.
                        RRAD   = &lt;float&gt;),%same as RADIUS but for radius in
                                          %the radiative core.
    track_fnames = [...], %List of filenames containing stellar evolution
                          %tracks to interpolate among.
    masses = [&lt;float&gt;, ...],        %list of stellar masses to use
    feh = [&lt;float&gt;, ...]            %list of stellar [Fe/H] values to use
    model_suite = &lt;str&gt;,            %The name of a preiously registered
                                    %suite of tracks to use in the
                                    %interpolation. POET comes with a suite
                                    %named 'MESA'.
    new_interp_name = &lt;str&gt; %A human-readable name to assign should an
                            %interpolator matching the other arguments
                            %does not exist.
    num_threads = &lt;int&gt; %The number of threads to use when deriving the
                        %interpolation.
)
</pre><p>As explained above, all subsequent calls to <code>get_interpolator</code> using the same parameters, will re-use the interpolator generated by the first call. Note the <code>new_interp_name</code> argument. If that argument is not supplied, and an interpolator matching the specified configuration is not found, the result is None.</p>
<h3>Solving for stellar mass and age which match other known properties</h3>
<p>Another useful task performed by the <a href="#StellarEvolutionReadMe">Stellar Evolution</a> module is to solver for the mass and age of a star given [Fe/H] and any two of: \(T_{eff}\), \(\log_{10}(g)\), \(L_\star\), \(\rho_\star\). This is done using the interpolators change_varables method. For example: </p><pre class="fragment">from poet.stellar_evolution.manager import StellarEvolutionManager
import numpy

%Create a manager
manager = StellarEvolutionManager(&lt;path to serialized interpolators&gt;)

%Find and use the default interpolator
interpolator = manager.get_interpolator_by_name('default')

solutions = manager.change_variables(
    feh = 0.0,
    teff = 6000,
    lum = 1.0
)
for mass, age in solutions :
    ....
</pre><h3>Custom stellar evolution tracks</h3>
<p>In is also possible to construct interpolations based on a set of tracks not packaged with POET. The tracks must be formatted as comma separated values, with the first line containing the names of the columns. All quantities required by POET must be tabulated. See the set of tracks shipped with POET for an example.</p>
<p>The first step is to register the tracks with the interpolation manager. This can be done track by track: </p><pre class="fragment">%Register a single stellar evolution track.
manager.register_track(&lt;filename&gt;,  %Name of the file contaning the track
                       mass,        %The stellar mass of the track (Msun)
                       metallicity, %[Fe/H] of the track.
                       model_suite) %Name of a track collection to assign
                                    %this track to.
</pre><p>If the names of the files can be parsed to extract the mass and metallicity, there is a shortcut: </p><pre class="fragment">%Register an entire collection of tracks at once with stellar mass and
%metallicity encoded in the filename.
manager.register_track_collection(
    [&lt;filename&gt;,...],     %List of track files
    &lt;regular expression&gt;, %A compiled python re which defines groups
                          %names 'MASS' and either 'Z' or '[Fe/H]'
                          %The package tracks match:
                          %'M(?P&lt;MASS&gt;[0-9.E+-]+)_Z(?P&lt;Z&gt;[0-9.E+-]+).csv'
    model_suite           %Name of a track collection to assign the
                          %tracks to
)
</pre><p>After registering the tracks, new interpolators can be generated and registered with the manager, either like we did above using the custom tracks, but this time we specify our new model suite. </p><pre class="fragment">% construct an interpolator using only a subset of the tracks, as well
% as custom smoothing and number of nodes.
interpolator = manager.get_interpolator(
    masses = [&lt;float&gt;, ...],        %list of stellar masses to use
    metallicities = [&lt;float&gt;, ...], %list of stellar metallicities to use
    model_suite = &lt;str&gt;,            %the model suite defined above
    nodes = dict(RADIUS = &lt;int&gt;,    %number of nodes for the radius age
                                    %interpolation
                 ICONV  = &lt;int&gt;,    %convective moment of inertia nodes
                 LUM    = &lt;int&gt;,      %luminosity nodes
                 IRAD   = &lt;int&gt;,    %radiative moment of inertia nodes
                 MRAD   = &lt;int&gt;,    %radiative mass nodes
                 RRAD   = &lt;int&gt;),   %tachocline radius nodes
    smoothing = dict(RADIUS = &lt;float&gt;,  %smoothing parameter for the
                                        %radius age interpolation
                     ICONV  = &lt;float&gt;,  %convective moment of inertia
                                        %smoothig
                     LUM    = &lt;float&gt;,  %luminosity smoothing
                     IRAD   = &lt;float&gt;,  %radiative moment of inertia
                                        %smoothing
                     MRAD   = &lt;float&gt;,  %radiative mass smoothing
                     RRAD   = &lt;float&gt;), %tachocline radius smoothing
    new_interp_name = &lt;str&gt; %A human-readable name to assign should an
                            %interpolator matching the other arguments
                            %not exist.
)
</pre><p>This only works if the new suite has only one track per mass-metallicity combination. If for example the new tracks again use <code>model_suite = MESA</code>, then which tracks to use must be specified by name: </p><pre class="fragment">% construct an interpolator using a custom set of tracks, as well
% as custom smoothing and number of nodes.
interpolator = manager.get_interpolator(
    track_fnames = [&lt;path&gt;, ...],   %list of filenames containing
                                    %the stellar evolution tracks
    nodes = &lt;same as above&gt;         
    smoothing = &lt;same as above&gt;
    new_interp_name = &lt;same as above&gt;
)</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Aug 24 2018 16:04:36 for poet by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
