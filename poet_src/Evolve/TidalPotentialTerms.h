/**\file
 *
 * \brief Declare an interface for evaluating the expansion of the tidal
 * potential.
 *
 * \ingroup Evolve_group
 */

#ifndef __TIDAL_POTENTIAL_TERMS_H
#define __TIDAL_POTENTIAL_TERMS_H

#include <cmath>
#include <valarray>
#include "EccentricityExpansionCoefficients.h"
#include "../Core/Common.h"

//TODO: No longer need to worry about e-order

namespace Evolve {
    class LIB_PUBLIC TidalPotentialTerms {
    private:
        ///The eccentricity expansion of \f$p_{m,s}\f$.
        static EccentricityExpansionCoefficients __pms;

        ///\brief The constant coefficiients in \f$\mathcal{U}_{m,m'}\f$ of Lai
        ///(2012).
        ///
        ///The first index is m+2 (since m starts from -2) and the second index
        ///is m'/2+1 since the only allowed values are -2, 0 and 1.
        static const double __Umm_coef[][3];

        ///The inclination with which __Ummp was last filled.
        double __Ummp_inclination;

        ///The argument of periaspsis set by the last call to configure().
        double __arg_of_periapsis;

        std::valarray< std::valarray<double> >
            ///The \f$\mathcal{U}_{m,m'}\f$ quantities defined in Lai (2012).
            __Ummp,

            ///\brief The derivatives of the \f$\mathcal{U}_{m,m'}\f$
            ///quantities w.r.t. the inclination.
            __Ummp_deriv;

    public:

        TidalPotentialTerms();

        ///\brief The maximum orbital frequency multiplier to include in the
        ///potential Fourier expansion in order to achive a specified precision.
        ///
        ///The return value (call it \f$O\f$) is such that \f$O p_{m, O+1} <
        //\mathrm{precision}\f$. The reasoning is that if \f$p_{m,s}\f$ will
        ///decay substantially as s doubles.
        static unsigned required_expansion_order(
            ///The eccentricity at which tidal potential needs to be evaluated.
            double e,

            ///The required precision
            double precision
        ) {return 0;}

        ///Set the inclination relative to the orbit.
        void configure(double inclination, double arg_of_periapsis = 0);

        ///\brief Calculates \f$\sum_s W_{2,s}D_{m,s}(\Theta)p_{s,m'}\f$ (see
        ///documentation) and its derivatives w.r.t. e and \f$\Theta\f$.
        ///
        ///configure() should already have been called with the appropriate
        ///inclination and argument of periapsis.
        void operator()(
            ///The eccentricity.
            double e,

            ///The m index (spin freuqency multiplier).
            int m,

            ///The m' index (orbital frequency multiplier).
            int mp,

            ///Set to the undifferentiated value.
            std::complex<double> &no_deriv,

            ///Set to the inclination derivative.
            std::complex<double> &inclination_deriv,

            ///Set to the eccentricity_derivative.
            std::complex<double> &eccentricity_deriv
        ) const;

        ///\brief Return only the real parts of the complex version of the
        ///operator, since only the real part enters the tidal torque and power.
        void operator()(
            ///The eccentricity.
            double e,

            ///The m index.
            int m,

            ///The m' index.
            int mp,

            ///Set to the undifferentiated value.
            double &no_deriv,

            ///Set to the inclination derivative.
            double &inclination_deriv,

            ///Set to the eccentricity_derivative.
            double &eccentricity_deriv
        ) const;

        ///\brief Reads the eccentricity expansion coefficients of \f$p_{m,s}\f$.
        ///
        ///The given file should have been generated by
        ///tabulate_eccentricity_expansion_coefficients.py.
        static void read_eccentricity_expansion(const std::string &fname)
        {__pms.read(fname);}

        ///\brief The maximum eccentricity expansion order for which the
        ///expansion is known.
        static unsigned max_expansion_order()
        {return __pms.max_orbital_frequency_multiplier() - 2;}
    }; //End TidalPotentialTerms class.
} //End Evolve namespace

#endif
